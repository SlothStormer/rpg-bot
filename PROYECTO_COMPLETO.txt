# CONTEXTO DEL PROYECTO
# Este archivo contiene el c√≥digo fuente concatenado.
# Ra√≠z del escaneo: C:/Users/Tomi/Documents/Programacion/Node/rpg-bot
# Cada secci√≥n comienza con '--- START OF FILE: [path] ---'



--- START OF FILE: drizzle.config.ts ---
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
    out: './drizzle',
    schema: './src/db/schema.ts',
    dialect: 'postgresql',
    dbCredentials: {
        url: process.env.DATABASE_URL!,
    },
});
--- END OF FILE: drizzle.config.ts ---


--- START OF FILE: package.json ---
{
  "name": "rpg-bot",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "tsx src/index.ts",
    "dev": "tsx --watch src/index.ts",
    "deploy-commands": "tsx src/deploy-commands.ts",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "dependencies": {
    "@neondatabase/serverless": "^1.0.2",
    "discord.js": "^14.25.1",
    "dotenv": "^17.2.3",
    "drizzle-orm": "^0.45.1"
  },
  "devDependencies": {
    "drizzle-kit": "^0.31.8",
    "tsx": "^4.21.0",
    "typescript": "^5.9.3"
  }
}
--- END OF FILE: package.json ---


--- START OF FILE: tsconfig.json ---
{
    "compilerOptions": {
        "target": "ESNext",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "outDir": "./dist",
        "esModuleInterop": true,
        "forceConsistentCasingInFileNames": true,
        "strict": true,
        "skipLibCheck": true
    },
    "include": [
        "src/**/*"
    ]
}
--- END OF FILE: tsconfig.json ---


--- START OF FILE: src\deploy-commands.ts ---
import { REST, Routes } from "discord.js";
import 'dotenv/config';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';

const TOKEN = process.env.TOKEN!;
const CLIENT_ID = process.env.CLIENT_ID!;
const GUILD_ID = process.env.GUILD_ID!;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const commands = [];

const foldersPath = path.join(__dirname, 'commands');
const commandFolders = fs.readdirSync(foldersPath);

for (const folder of commandFolders) {
    const commandsPath = path.join(foldersPath, folder);
    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js') || file.endsWith('.ts'));

    for (const file of commandFiles) {
        const filePath = path.join(commandsPath, file);
        const command = await import(pathToFileURL(filePath).href);

        if (command.default && 'data' in command.default && 'execute' in command.default) {
            commands.push(command.default.data.toJSON());
            console.log(`[LOAD] Preparando comando: ${command.default.data.name}`);
        } else {
            console.log(`[WARNING] El comando en ${filePath} falta "data" o "execute".`);
        }
    }
}

// --- ENV√çO A LA API ---
const rest = new REST({ version: '10' }).setToken(TOKEN);

(async () => {
    try {
        console.log(`Empezando a refrescar ${commands.length} comandos (/) de aplicaci√≥n.`);

        const data = await rest.put(
            Routes.applicationGuildCommands(CLIENT_ID, GUILD_ID),
            { body: commands },
        ) as any;

        console.log(`¬°√âxito! Se han registrado ${data.length} comandos en el servidor.`);
    } catch (error) {
        console.error(error);
    }
})();
--- END OF FILE: src\deploy-commands.ts ---


--- START OF FILE: src\index.ts ---
// index.js
import { Client, Collection, Events, GatewayIntentBits } from "discord.js";
import 'dotenv/config'
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const client = new Client({
    intents: [GatewayIntentBits.Guilds]
})

// Colleccion para guardar los comandos en memoria
client.commands = new Collection();

// Command handler
const foldersPath = path.join(__dirname, 'commands');
const commandFolders = fs.readdirSync(foldersPath);

for (const folder of commandFolders) {
    const commandsPath = path.join(foldersPath, folder);
    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js') || file.endsWith('.ts'));

    for (const file of commandFiles) {
        const filePath = path.join(commandsPath, file);

        const command = await import(pathToFileURL(filePath).href);

        if (command.default && 'data' in command.default && 'execute' in command.default) {
            client.commands.set(command.default.data.name, command.default);
            console.log(`[INFO] Comando cargado: ${command.default.data.name}`);
        } else {
            console.log(`[WARNING] El comando en ${filePath} no tiene la estructura correcta.`);
            console.log(`-> Aseg√∫rate de usar "export default { data: ..., execute: ... }"`);
        }
    }
}

client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isChatInputCommand()) return;

    const command = interaction.client.commands.get(interaction.commandName);

    if (!command) {
        console.error(`No se encontr√≥ comando para ${interaction.commandName}`);
        return;
    }

    try {
        await command.execute(interaction);
    } catch (error) {
        console.error(error);
        if (interaction.replied || interaction.deferred) {
            await interaction.followUp({ content: 'Hubo un error ejecutando este comando!', ephemeral: true });
        } else {
            await interaction.reply({ content: 'Hubo un error ejecutando este comando!', ephemeral: true });
        }
    }
});

client.once(Events.ClientReady, readyClient => {
    console.log(`Bot RPG Online! Logueado como ${readyClient.user.tag}`);
});

client.login(process.env.TOKEN);
--- END OF FILE: src\index.ts ---


--- START OF FILE: src\types.d.ts ---
import { Collection } from "discord.js";

declare module "discord.js" {
    export interface Client {
        commands: Collection<string, any>;
    }
}

--- END OF FILE: src\types.d.ts ---


--- START OF FILE: src\commands\rpg\profile.ts ---
import { ChatInputCommandInteraction, EmbedBuilder, MessageFlags, SlashCommandBuilder } from "discord.js"
import { db } from "../../db/index.js";
import { users } from "../../db/schema.js";
import { eq } from "drizzle-orm";
import { ZONES } from "../../const/zones.js";

export default {
    data: new SlashCommandBuilder()
        .setName('perfil')
        .setDescription('Muestra tu perfil'),
    async execute(interaction: ChatInputCommandInteraction) {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });

        const userId = interaction.user.id;

        let user = await db.select().from(users).where(eq(users.discordId, userId))

        console.log(user);

        if (user.length === 0) {
            await interaction.editReply({ content: 'No estas registrado en la asociacion de aventureros' });
            return;
        }

        const playerData = user[0];

        const actualZone = ZONES.find(zone => zone.value === playerData.currentZone);

        // 3. Responder
        const embed = new EmbedBuilder()
            .setTitle(`Perfil de ${playerData.username}`)
            .setColor(0x00AE86)
            .addFields(
                { name: 'üí∞ Oro', value: `${playerData.balance}`, inline: true },
                { name: '‚ú® XP', value: `${playerData.xp}`, inline: true },
                { name: 'üåç Zona', value: `${actualZone?.name}`, inline: true },
            );

        await interaction.editReply({ embeds: [embed] });
    }
}
--- END OF FILE: src\commands\rpg\profile.ts ---


--- START OF FILE: src\commands\rpg\register.ts ---
import { ChatInputCommandInteraction, MessageFlags, SlashCommandBuilder } from "discord.js"
import { db } from "../../db/index.js";
import { users } from "../../db/schema.js";
import { eq } from "drizzle-orm";

export default {
    data: new SlashCommandBuilder()
        .setName('inscribirse')
        .setDescription('Inscribete a la asociacion de aventureros'),
    async execute(interaction: ChatInputCommandInteraction) {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });

        const userId = interaction.user.id;

        let user = await db.select().from(users).where(eq(users.discordId, userId))

        console.log(user);

        if (user.length > 0) {
            await interaction.editReply({ content: 'Ya estas inscrito a la asociacion de aventureros' });
            return;
        }

        const newUser = await db.insert(users).values({
            discordId: userId,
            username: interaction.user.username,
            balance: 100,
            xp: 0,
        }).returning();

        console.log(newUser);

        await interaction.editReply({ content: 'Has inscrito a tu personaje en la asociacion de aventureros' });
    }
}
--- END OF FILE: src\commands\rpg\register.ts ---


--- START OF FILE: src\commands\rpg\travel.ts ---
import { MessageFlags, SlashCommandBuilder, ChatInputCommandInteraction } from "discord.js";
import { ZONES } from "../../const/zones.js";
import { db } from "../../db/index.js";
import { users } from "../../db/schema.js";
import { eq } from "drizzle-orm";

export default {
    data: new SlashCommandBuilder()
        .setName('viajar')
        .setDescription('Viaja a una zona diferente')
        .addStringOption(option =>
            option.setName('destino')
                .setDescription('A donde queres viajar')
                .setRequired(true)
                .addChoices(...ZONES)
        ),
    async execute(interaction: ChatInputCommandInteraction) {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });
        const destino = interaction.options.getString('destino');

        const userId = interaction.user.id;

        let user = await db.select().from(users).where(eq(users.discordId, userId))
        if (user.length === 0) {
            await interaction.editReply({ content: 'No estas registrado en la asociacion de aventureros' });
            return;
        }

        const zona = ZONES.find(zona => zona.value === destino);
        if (!zona) {
            await interaction.editReply({ content: 'Esa zona no existe.' });
            return;
        }

        const updatedUser = await db.update(users).set({ currentZone: zona.value }).where(eq(users.discordId, userId)).returning();

        await interaction.editReply({ content: `${interaction.user} estas viajando a **${zona.name}**...` });
    }
}
--- END OF FILE: src\commands\rpg\travel.ts ---


--- START OF FILE: src\commands\utils\ping.ts ---
import { ChatInputCommandInteraction, SlashCommandBuilder } from 'discord.js'

export default {
    data: new SlashCommandBuilder()
        .setName('ping')
        .setDescription('Replies with Pong!'),
    async execute(interaction: ChatInputCommandInteraction) {
        await interaction.reply('Pong!')
    }
}
--- END OF FILE: src\commands\utils\ping.ts ---


--- START OF FILE: src\const\zones.ts ---
export const ZONES = [
    { name: 'Pueblo Inicial', value: 'town_01' },
    { name: 'Bosque Oscuro', value: 'forest_01' },
    { name: 'Cueva de los Goblins', value: 'cave_01' },
] as const;
--- END OF FILE: src\const\zones.ts ---


--- START OF FILE: src\db\index.ts ---
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
import "dotenv/config"

if (!process.env.DATABASE_URL) {
    throw new Error("DATABASE_URL no est√° definido en .env");
}

const sql = neon(process.env.DATABASE_URL);
export const db = drizzle(sql);
--- END OF FILE: src\db\index.ts ---


--- START OF FILE: src\db\schema.ts ---
import { pgTable, serial, text, integer, boolean } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
    id: serial('id').primaryKey(),
    discordId: text('discord_id').notNull().unique(),
    username: text('username'),
    balance: integer('balance').default(0),
    xp: integer('xp').default(0),
    currentZone: text('current_zone').default('town_01'),
})
--- END OF FILE: src\db\schema.ts ---
